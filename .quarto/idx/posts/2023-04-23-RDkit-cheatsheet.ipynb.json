{"title":"RDkit cheatsheet","markdown":{"yaml":{"badges":true,"author":"Samdani Ansar","categories":["Cheminformatics"],"date":"2023-06-20","title":"RDkit cheatsheet","description":"Making RDkit easy","toc":true,"image":"images/STI.png"},"headingText":"Install Dependecies","containsRefs":false,"markdown":"\n\nThis notebook will provide you the basic concepts used in RDkit and its functionalites.\n\nTo run the notebook in Google Colab. [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/pablo-arantes/making-it-rain/blob/main/Partial_Charges.ipynb)\n\n\n\n\nFor more information on RDKit can be found [here](https://www.rdkit.org/docs/GettingStartedInPython.html)\n\n# Read molecules\n\nFor reading different files into RDkit\n* Chem.MolFromMolFile (From SDF file)\n* Chem.MolFromPDBFile (From PDB file)\n* Chem.MolFromSmarts (From smarts as string text)\n* Chem.MolFromSmiles (From smiles as string text)\n* Chem.MolFromMol2File (MOL2 file only tripos mol2 file format accepted)\n\nFor reading multiple files:\n* Chem.SmilesMolSupplier\n* Chem.SDMolSupplier\n\n\n# Compute 2D coordinates\n\n# Compute 3D coordinates\n\n# write molecules\n\nFor writing many molecules:\n* Chem.SDWriter (For saving in sdf file)\n* Chem.SmilesWriter (For saving in smiles file)\n* Chem.PDBWriter (For saving in smiles file)\n\nFor single molecule\n* Chem.MolToMolFile (For saving sdf file)\n* Chem.MolToPDBFile (For saving pdb file)\n* Chem.MolToSmiles (For saving smiles file)\n\n\nWriting multiple smiles\n\n## Writing SDF file\n\n# Conformer generation\n\n# Draw Molecules\n\nThe RDKit has some built-in functionality for creating images from molecules found in the rdkit.Chem.Draw package\n\nAtoms in a molecule can be highlighted by drawing a coloured solid or open circle around them, and bonds likewise can have a coloured outline applied. An obvious use is to show atoms and bonds that have matched a substructure query\n\n# Fingerprint\n\nIn RDKit, a molecular fingerprint is a binary vector that encodes the presence or absence of specific molecular features or substructures within a molecule. Fingerprinting is commonly used for comparing the similarity or dissimilarity of different molecules, for example in virtual screening or similarity searches.\n\nRDKit supports various types of fingerprints, including the Morgan fingerprint (also known as the circular fingerprint), the extended-connectivity fingerprint (ECFP), and the MACCS keys fingerprint. These fingerprints differ in terms of their underlying algorithm and the specific molecular features they encode.\n\nTo generate a fingerprint for a given molecule in RDKit, the molecule is first processed to generate a list of substructures or features, which are then used to generate the binary fingerprint vector. This process can be customized to include or exclude specific features or adjust the size of the fingerprint vector.\n\nOnce generated, fingerprints can be compared using similarity metrics such as the Tanimoto similarity coefficient, which measures the overlap between two fingerprints. \n\nMore information and description about fingerprint can be found [here](https://www.rdkit.org/UGM/2012/Landrum_RDKit_UGM.Fingerprints.Final.pptx.pdf).\n\n## MACCS\n\nThe MACCS keys are a widely used set of 166 binary structural keys that encode various structural features of a molecule, such as presence or absence of certain functional groups, ring systems, and bond types. The resulting MACCS keys fingerprint is a binary vector that represents the presence or absence of each of the 166 keys in the molecule.\n\n## ECFP4\n\n# Fragmenting molecules\n\n## RECAP\n\nRECAP module is used to break down a molecule into fragments and generate a hierarchical representation of the molecule's scaffold. This can be useful for analyzing and comparing the structures of related molecules. It breaks the molecules based on chemical transformations mimicking common reactions carried out in the lab in order to decompose a molecule into a series of reasonable fragments.\n\n\n\n\n## BRICS\n\nBRICS provides another method for fragmenting molecules along synthetically accessible bonds:\n\n# Calculating descriptors\n\nIn cheminformatics, descriptors are numeric or categorical properties of a molecule that can be used to characterize and compare different compounds. These descriptors are often calculated based on the molecular structure, and can provide information on a variety of chemical properties, such as molecular size, shape, and polarity.\n\nRDKit offers a wide range of descriptor calculation methods, which can be used to generate descriptors for a given molecule or set of molecules. These methods include both 1D descriptors, which are calculated based on the atom types and bond connectivity within a molecule, and 2D descriptors, which take into account the spatial arrangement of atoms in the molecule.\n\nSome examples of the types of descriptors that can be calculated using RDKit include topological descriptors, such as the number of atoms and bonds in a molecule, as well as more complex descriptors, such as pharmacophoric and quantum chemical descriptors. These descriptors can be used in a variety of applications, including drug discovery, chemical reaction prediction, and toxicity prediction, among others.\n\n1D descriptors: number of atoms, number of bonds, molecular weight, logP\n\n2D descriptors: polarizability, electronegativity, and hydrogen bonding potential\n\n3D descriptors: molecular volume, solvent-accessible surface area, moment of inertia, distance matrix\n\nMore information on available descriptors in rdkit is available [here](https://www.rdkit.org/docs/GettingStartedInPython.html#list-of-available-descriptors)\n\n\n# Reading as pandas dataframe\n\n# Maximum common substructure\n\nMCS (Maximum Common Substructure) is a commonly used algorithm in cheminformatics for identifying the largest common substructure among a set of molecules. In RDKit, the ***rdkit.Chem.rdFMCS*** module provides a function ***FindMCS*** to calculate the MCS of a set of molecules. \n\n# Substructure match\n\nSubstructure matching is the process of finding substructures (i.e., patterns) within a molecule that match a given query pattern. Substructure matching can be used for a variety of tasks in cheminformatics, including **identifying compounds that contain a particular functional group or substructure, filtering a set of molecules based on a specific pattern, and identifying potential toxicophores or structural alerts in a dataset**.\n\n### Sterochemistry in substructures\n\nBy default information about stereochemistry is not used in substructure searches. useChirality can be used to set sterochemistry based pattern search.\n\nNotice that when useChirality is set a non-chiral query does match a chiral molecule. The same is not true for a chiral query and a non-chiral molecule:\n\n# Synthetic accessibility\n\nSynthetic accessibility is a measure of how easy or difficult it is to synthesize a given molecule using established chemical methods.  SAscores can be useful for prioritizing compounds for synthesis and for identifying potentially problematic structures that may be difficult or costly to synthesize.The SA_score ranges from 1 to 10, with higher scores indicating greater synthetic accessibility.\n\n# Clustering molecules\n\n# Bond order PDB\n\n# Join two molecule\n\nmolzip lets you take a molecule containing multiple fragments and “zip” them together. The atoms which should be bonded in the final molecule are labelled by connecting them to dummy atoms. The code identifies matching dummy atoms (by default this means dummies with the same isotopic label) in the fragments, adds bonds between the atoms connected to the dummies, and then removes the dummies.\n\nFrag1 has dummy atom labelled [\\*:2]\n\nFrag2 has dummy atom labelled [\\*:1]\n\nFrag3 has two dummy atoms labelled [\\*:1] and [\\*:2].\n\nNow the molzip will take the fragments frag1 and combine to frag3 by search dummy atom labels [\\*:1]\n\nsimilary frag2 is attached to frag3 by searching dummy atom label [\\*:2].\n\nBy specifying at which particular point the fragments to be connected by the dummy atom labelling the molecules could be combined.\n","srcMarkdownNoYaml":"\n\nThis notebook will provide you the basic concepts used in RDkit and its functionalites.\n\nTo run the notebook in Google Colab. [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/pablo-arantes/making-it-rain/blob/main/Partial_Charges.ipynb)\n\n\n\n# Install Dependecies\n\nFor more information on RDKit can be found [here](https://www.rdkit.org/docs/GettingStartedInPython.html)\n\n# Read molecules\n\nFor reading different files into RDkit\n* Chem.MolFromMolFile (From SDF file)\n* Chem.MolFromPDBFile (From PDB file)\n* Chem.MolFromSmarts (From smarts as string text)\n* Chem.MolFromSmiles (From smiles as string text)\n* Chem.MolFromMol2File (MOL2 file only tripos mol2 file format accepted)\n\nFor reading multiple files:\n* Chem.SmilesMolSupplier\n* Chem.SDMolSupplier\n\n\n# Compute 2D coordinates\n\n# Compute 3D coordinates\n\n# write molecules\n\nFor writing many molecules:\n* Chem.SDWriter (For saving in sdf file)\n* Chem.SmilesWriter (For saving in smiles file)\n* Chem.PDBWriter (For saving in smiles file)\n\nFor single molecule\n* Chem.MolToMolFile (For saving sdf file)\n* Chem.MolToPDBFile (For saving pdb file)\n* Chem.MolToSmiles (For saving smiles file)\n\n\nWriting multiple smiles\n\n## Writing SDF file\n\n# Conformer generation\n\n# Draw Molecules\n\nThe RDKit has some built-in functionality for creating images from molecules found in the rdkit.Chem.Draw package\n\nAtoms in a molecule can be highlighted by drawing a coloured solid or open circle around them, and bonds likewise can have a coloured outline applied. An obvious use is to show atoms and bonds that have matched a substructure query\n\n# Fingerprint\n\nIn RDKit, a molecular fingerprint is a binary vector that encodes the presence or absence of specific molecular features or substructures within a molecule. Fingerprinting is commonly used for comparing the similarity or dissimilarity of different molecules, for example in virtual screening or similarity searches.\n\nRDKit supports various types of fingerprints, including the Morgan fingerprint (also known as the circular fingerprint), the extended-connectivity fingerprint (ECFP), and the MACCS keys fingerprint. These fingerprints differ in terms of their underlying algorithm and the specific molecular features they encode.\n\nTo generate a fingerprint for a given molecule in RDKit, the molecule is first processed to generate a list of substructures or features, which are then used to generate the binary fingerprint vector. This process can be customized to include or exclude specific features or adjust the size of the fingerprint vector.\n\nOnce generated, fingerprints can be compared using similarity metrics such as the Tanimoto similarity coefficient, which measures the overlap between two fingerprints. \n\nMore information and description about fingerprint can be found [here](https://www.rdkit.org/UGM/2012/Landrum_RDKit_UGM.Fingerprints.Final.pptx.pdf).\n\n## MACCS\n\nThe MACCS keys are a widely used set of 166 binary structural keys that encode various structural features of a molecule, such as presence or absence of certain functional groups, ring systems, and bond types. The resulting MACCS keys fingerprint is a binary vector that represents the presence or absence of each of the 166 keys in the molecule.\n\n## ECFP4\n\n# Fragmenting molecules\n\n## RECAP\n\nRECAP module is used to break down a molecule into fragments and generate a hierarchical representation of the molecule's scaffold. This can be useful for analyzing and comparing the structures of related molecules. It breaks the molecules based on chemical transformations mimicking common reactions carried out in the lab in order to decompose a molecule into a series of reasonable fragments.\n\n\n\n\n## BRICS\n\nBRICS provides another method for fragmenting molecules along synthetically accessible bonds:\n\n# Calculating descriptors\n\nIn cheminformatics, descriptors are numeric or categorical properties of a molecule that can be used to characterize and compare different compounds. These descriptors are often calculated based on the molecular structure, and can provide information on a variety of chemical properties, such as molecular size, shape, and polarity.\n\nRDKit offers a wide range of descriptor calculation methods, which can be used to generate descriptors for a given molecule or set of molecules. These methods include both 1D descriptors, which are calculated based on the atom types and bond connectivity within a molecule, and 2D descriptors, which take into account the spatial arrangement of atoms in the molecule.\n\nSome examples of the types of descriptors that can be calculated using RDKit include topological descriptors, such as the number of atoms and bonds in a molecule, as well as more complex descriptors, such as pharmacophoric and quantum chemical descriptors. These descriptors can be used in a variety of applications, including drug discovery, chemical reaction prediction, and toxicity prediction, among others.\n\n1D descriptors: number of atoms, number of bonds, molecular weight, logP\n\n2D descriptors: polarizability, electronegativity, and hydrogen bonding potential\n\n3D descriptors: molecular volume, solvent-accessible surface area, moment of inertia, distance matrix\n\nMore information on available descriptors in rdkit is available [here](https://www.rdkit.org/docs/GettingStartedInPython.html#list-of-available-descriptors)\n\n\n# Reading as pandas dataframe\n\n# Maximum common substructure\n\nMCS (Maximum Common Substructure) is a commonly used algorithm in cheminformatics for identifying the largest common substructure among a set of molecules. In RDKit, the ***rdkit.Chem.rdFMCS*** module provides a function ***FindMCS*** to calculate the MCS of a set of molecules. \n\n# Substructure match\n\nSubstructure matching is the process of finding substructures (i.e., patterns) within a molecule that match a given query pattern. Substructure matching can be used for a variety of tasks in cheminformatics, including **identifying compounds that contain a particular functional group or substructure, filtering a set of molecules based on a specific pattern, and identifying potential toxicophores or structural alerts in a dataset**.\n\n### Sterochemistry in substructures\n\nBy default information about stereochemistry is not used in substructure searches. useChirality can be used to set sterochemistry based pattern search.\n\nNotice that when useChirality is set a non-chiral query does match a chiral molecule. The same is not true for a chiral query and a non-chiral molecule:\n\n# Synthetic accessibility\n\nSynthetic accessibility is a measure of how easy or difficult it is to synthesize a given molecule using established chemical methods.  SAscores can be useful for prioritizing compounds for synthesis and for identifying potentially problematic structures that may be difficult or costly to synthesize.The SA_score ranges from 1 to 10, with higher scores indicating greater synthetic accessibility.\n\n# Clustering molecules\n\n# Bond order PDB\n\n# Join two molecule\n\nmolzip lets you take a molecule containing multiple fragments and “zip” them together. The atoms which should be bonded in the final molecule are labelled by connecting them to dummy atoms. The code identifies matching dummy atoms (by default this means dummies with the same isotopic label) in the fragments, adds bonds between the atoms connected to the dummies, and then removes the dummies.\n\nFrag1 has dummy atom labelled [\\*:2]\n\nFrag2 has dummy atom labelled [\\*:1]\n\nFrag3 has two dummy atoms labelled [\\*:1] and [\\*:2].\n\nNow the molzip will take the fragments frag1 and combine to frag3 by search dummy atom labels [\\*:1]\n\nsimilary frag2 is attached to frag3 by searching dummy atom label [\\*:2].\n\nBy specifying at which particular point the fragments to be connected by the dummy atom labelling the molecules could be combined.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"2023-04-23-RDkit-cheatsheet.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.361","theme":{"dark":"darkly","light":"flatly"},"badges":true,"author":"Samdani Ansar","categories":["Cheminformatics"],"date":"2023-06-20","title":"RDkit cheatsheet","description":"Making RDkit easy","image":"images/STI.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}